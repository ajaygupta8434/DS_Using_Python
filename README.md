Python:
Python is a programming language used to create software, websites, applications, automation tools, and systems related to data science, machine learning, and artificial intelligence.
Key features of Python
‚Ä¢	 Easy to learn ‚Äì syntax is close to plain English
‚Ä¢	 Interpreted language ‚Äì code is executed line by line
‚Ä¢	 Platform independent ‚Äì runs on Windows, Linux, and macOS
‚Ä¢	 Large standard library ‚Äì many built-in modules available
‚Ä¢	 General-purpose language ‚Äì used for many types of applications
Where is Python used?
‚Ä¢	 Web development 
‚Ä¢	 Data Science & Data Analysis
‚Ä¢	 Machine Learning & Artificial Intelligence
‚Ä¢	 Automation & Scripting
‚Ä¢	 Game development
‚Ä¢	 Desktop GUI applications
History of Python
Origin
‚Ä¢	Creator: Guido van Rossum
‚Ä¢	Country: Netherlands
‚Ä¢	Development started: Late 1980s
‚Ä¢	First release: 1991
Guido van Rossum was working at CWI (Centrum Wiskunde & Informatica) in the Netherlands. During Christmas holidays, he started developing Python as a hobby project.
Why the name ‚ÄúPython‚Äù?
‚Ä¢	The name Python does not come from the snake üêç
‚Ä¢	It comes from the British comedy show ‚ÄúMonty Python‚Äôs Flying Circus‚Äù
‚Ä¢	That‚Äôs why Python documentation often uses funny examples

Major Versions and Timeline
Python 1.x (1991)
‚Ä¢	Basic features
‚Ä¢	Core data types like lists, strings, and dictionaries
‚Ä¢	Simple and clean syntax
Python 2.x (2000)
‚Ä¢	Introduced list comprehensions
‚Ä¢	Better memory management
‚Ä¢	Became very popular in industry
‚Ä¢	‚ö†Ô∏è Python 2 officially ended in 2020
Python 3.x (2008 ‚Äì Present)
‚Ä¢	Fixed many design issues of Python 2
‚Ä¢	Better Unicode support
‚Ä¢	Faster and more consistent
‚Ä¢	Current and recommended version
üëâ Today, Python 3 is the standard version used everywhere.
Advantages of Python
1.	Easy to Learn and Use
Python has simple, English-like syntax, which makes it ideal for beginners.
2.	High-Level Language
Programmers do not need to worry about memory management or hardware details.
3.	Interpreted Language
Code is executed line by line, making debugging easier.
4.	Platform Independent
Python programs can run on Windows, Linux, and macOS without modification.
5.	Large Standard Library
Python provides many built-in modules for file handling, math, networking, etc.
6.	Supports Multiple Programming Paradigms
Supports procedural, object-oriented, and functional programming.
7.	Open Source and Free
Python is free to use and has a strong open-source community.
8.	Strong Community Support
Large community means better documentation, tutorials, and third-party libraries.
9.	Used in Emerging Technologies
Widely used in Data Science, Machine Learning, AI, and Automation.

Disadvantages of Python
1.	Slower Execution Speed
Python is slower than compiled languages like C and C++.
2.	High Memory Consumption
Python programs use more memory compared to low-level languages.
3.	Not Ideal for Mobile App Development
Python is rarely used for native Android or iOS apps.
4.	Runtime Errors
Being dynamically typed, some errors appear only during execution.
5.	Weak in Multithreading
Due to the Global Interpreter Lock (GIL), true multithreading is limited.
6.	Database Access Can Be Slower
Compared to languages like Java, database connectivity may be slower.
C vs C++ vs Python (Complete Comparison)
C, C++, and Python are popular programming languages, but they differ in level, features, and usage.
Feature	C	C++	Python
Year	1972	1985	1991
Developer	Dennis Ritchie	Bjarne Stroustrup	Guido van Rossum
Level	Low-level	Mid-level	High-level
Language Type	Procedural	Object-Oriented + Procedural	Object-Oriented
Syntax	Complex	More complex	Very simple
Compilation	Compiled	Compiled	Interpreted
Speed	Very fast	Very fast	Slower
Memory Management	Manual	Manual + partial automatic	Automatic
Platform Independent	No	No	yes






How Python Works (Step-by-Step)
Python follows a compile + interpret execution process.
1 Writing Source Code
You write Python code in a .py file:
print("Hello World")
This code is human-readable.
2 Compilation to Bytecode
‚Ä¢	The Python interpreter first compiles the source code.
‚Ä¢	It converts the code into bytecode, not directly into machine code.
Bytecode is:
‚Ä¢	Low-level
‚Ä¢	Platform independent
3 Bytecode Storage
‚Ä¢	The generated bytecode is stored in the __pycache__ folder.
‚Ä¢	File extension: .pyc
If the source code is not changed, Python can reuse the bytecode in future runs.
4 Python Virtual Machine (PVM)
‚Ä¢	The Python Virtual Machine (PVM) executes the bytecode.
‚Ä¢	It reads and runs the bytecode line by line.
PVM is responsible for the actual execution of the program.
5 Output
‚Ä¢	The program produces the final output or error messages.

Source Code (.py)
        ‚Üì
Python Compiler
        ‚Üì
Bytecode (.pyc)
        ‚Üì
Python Virtual Machine (PVM)
        ‚Üì
Output

What is Bytecode?
Bytecode is a low-level, platform-independent code that is created from Python source code and executed by the Python Virtual Machine (PVM).
How Bytecode is Generated
1.	You write Python code (.py)
2.	Python compiler converts it into bytecode
3.	Bytecode is executed by PVM
Where is Bytecode Stored?
‚Ä¢	Stored in the __pycache__ folder
‚Ä¢	File extension: .pyc
Why Bytecode is Used?
‚Ä¢	Makes Python platform independent
‚Ä¢	Improves execution speed on repeated runs
‚Ä¢	Separates compilation and execution
Characteristics of Bytecode
‚Ä¢	Not machine code
‚Ä¢	Not human-readable
‚Ä¢	Same bytecode can run on any OS with Python installed
‚Ä¢	Executed by Python Virtual Machine
Python Bytecode vs Machine Code
Python bytecode and machine code are different levels of code execution.
Feature	Python Bytecode	Machine Code
Definition	Intermediate code generated by Python	Low-level code executed directly by CPU
Generated By	Python compiler	Language compiler (C/C++ compiler)
Executed By	Python Virtual Machine (PVM)	CPU (hardware)
Readability	Not human-readable	Not human-readable
Platform Dependent	‚ùå No (platform independent)	‚úÖ Yes (platform dependent)
Speed	Slower	Very fast
File Extension	.pyc	.exe, .out

What is PVM?
PVM is a virtual machine that executes Python bytecode and converts it into machine-level instructions for the CPU
Role of PVM in Python
‚Ä¢	Executes bytecode (.pyc)
‚Ä¢	Runs instructions line by line
‚Ä¢	Manages memory
‚Ä¢	Handles exceptions and errors
‚Ä¢	Makes Python platform independent








Source Code (.py)
        ‚Üì
Python Compiler
        ‚Üì
Bytecode (.pyc)
        ‚Üì
Python Virtual Machine (PVM)
        ‚Üì
CPU ‚Üí Output

Difference: PVM vs JVM
Feature	PVM	JVM
Full Form	Python Virtual Machine	Java Virtual Machine
Executes	Python Bytecode	Java Bytecode
Language	Python	Java
Compilation	At runtime	Before execution
Speed	Slower	Faster
Syntax of Python (Basics)
Python syntax is simple, clean, and easy to read.
It does not use braces {} or semicolons ; to define code blocks.



 Indentation (Most Important Rule)
Python uses indentation to define blocks of code.
‚ùå Incorrect:
if x > 5:
print("Hello")
‚úÖ Correct:
if x > 5:
    print("Hello")
üëâ Standard indentation is 4 spaces.
Case Sensitivity
Python is case-sensitive.
name = "Python"
Name = "Java"
name and Name are different variables.
Comments
Comments are used to explain code.
Single-line comment
# This is a comment
Multi-line comment
"""
This is a
multi-line comment
"""
 
1. Numeric Data Types
 Numeric Data Types
Python numbers represent data that has a numeric value. A numeric value can be an integer, a floating number or even a complex number. These values are defined as int, float and complex classes.

‚Ä¢	Integers: value is represented by int class. It contains positive or negative whole numbers (without fractions or decimals). There is no limit to how long an integer value can be.

‚Ä¢	Float: value is represented by float class. It is a real number with a floating-point representation. It is specified by a decimal point. Optionally, character e or E followed by a positive or negative integer may be appended to specify scientific notation.

‚Ä¢	Complex Numbers: It is represented by a complex class. It is specified as (real part) + (imaginary part)j. For example - 2+3j

a = 5
print(type(a))

b = 5.0
print(type(b))

c = 2 + 4j
print(type(c))

Output
<class 'int'>
<class 'float'>
<class 'complex'>


________________________________________
2. Sequence Data Types
A sequence is an ordered collection of items, which can be of similar or different data types. Sequences allow storing of multiple values in an organized and efficient fashion. There are several sequence data types of Python:
________________________________________
(a) list
Definition:
Lists are similar to arrays found in other languages. They are an ordered and mutable collection of items. It is very flexible as items in a list do not need to be of the same type.
Creating a List in Python
Lists in Python can be created by just placing sequence inside the square brackets[].
 Example:
# Empty list
a = []

# list with int values
a = [1, 2, 3]
print(a)

# list with mixed values int and String
b = ["Geeks", "For", "Geeks", 4, 5]
print(b)

Output
[1, 2, 3]
['Geeks', 'For', 'Geeks', 4, 5]
Access List Items
In order to access the list items refer to index number. In Python, negative sequence indexes represent positions from end of the array. Instead of having to compute offset as in List[len(List)-3], it is enough to just write List[-3]. Negative indexing means beginning from end, -1 refers to last item, -2 refers to second-last item, etc.
a = ["Geeks", "For", "Geeks"]
print("Accessing element from the list")
print(a[0])
print(a[2])

print("Accessing element using negative indexing")
print(a[-1])
print(a[-3])
Output
Accessing element from the list
Geeks
Geeks
Accessing element using negative indexing
Geeks
Geeks


 
________________________________________
(b) tuple
Definition:
Tuple is an ordered collection of Python objects. The only difference between a tuple and a list is that tuples are immutable. Tuples cannot be modified after it is created.
Creating a Tuple in Python
In Python, tuples are created by placing a sequence of values separated by a ‚Äòcomma‚Äô with or without the use of parentheses for grouping data sequence. Tuples can contain any number of elements and of any datatype (like strings, integers, lists, etc.).
Note: Tuples can also be created with a single element, but it is a bit tricky. Having one element in the parentheses is not sufficient, there must be a trailing ‚Äòcomma‚Äô to make it a tuple.
Example:
# initiate empty tuple
tup1 = ()

tup2 = ('Geeks', 'For')
print("\nTuple with the use of String: ", tup2) Output
Tuple with the use of String:  ('Geeks', 'For')
 Access Tuple Items
In order to access tuple items refer to the index number. Use the index operator [ ] to access an item in a tuple.
tup1 = (1, 2, 3, 4, 5)
# access tuple items
print(tup1[0])
print(tup1[-1])
print(tup1[-3]) 
Output
1
5
3

________________________________________
(c) string
Python Strings are arrays of bytes representing Unicode characters. In Python, there is no character data type, a character is a string of length one. It is represented by str class.
Strings in Python can be created using single quotes, double quotes or even triple quotes. We can access individual characters of a String using index.
Example:
s = 'Welcome to the Geeks World'
print(s)
# check data type 
print(type(s))
# access string with index
print(s[1])
print(s[2])
print(s[-1]) 
Output
Welcome to the Geeks World
<class 'str'>
e
l
d
No.	Method	Definition	Syntax	Example
1	capitalize()	First letter capital	str.capitalize()	"hello".capitalize() ‚Üí "Hello"
2	casefold()	Lowercase (stronger than lower)	str.casefold()	"HELLO".casefold() ‚Üí "hello"
3	lower()	Convert to lowercase	str.lower()	"HELLO".lower() ‚Üí "hello"
4	upper()	Convert to uppercase	str.upper()	"hello".upper() ‚Üí "HELLO"
5	swapcase()	Change upper ‚Üî lower	str.swapcase()	"HeLLo".swapcase() ‚Üí "hEllO"
6	title()	First letter of each word capital	str.title()	"hello world".title() ‚Üí "Hello World"
7	center()	Center align string	str.center(width)	"hi".center(6) ‚Üí " hi "
8	ljust()	Left align	str.ljust(width)	"hi".ljust(5) ‚Üí "hi "
9	rjust()	Right align	str.rjust(width)	"hi".rjust(5) ‚Üí " hi"
10	zfill()	Fill zeros left	str.zfill(width)	"5".zfill(3) ‚Üí "005"
11	find()	Find position	str.find(value)	"hello".find("e") ‚Üí 1
12	rfind()	Find from right	str.rfind(value)	"hello".rfind("l") ‚Üí 3
13	index()	Find position (error if not found)	str.index(value)	"hello".index("e") ‚Üí 1
14	rindex()	Find from right (error if not found)	str.rindex(value)	"hello".rindex("l") ‚Üí 3
15	count()	Count occurrences	str.count(value)	"hello".count("l") ‚Üí 2
16	isalnum()	Letters & numbers only	str.isalnum()	"abc123".isalnum() ‚Üí True
17	isalpha()	Letters only	str.isalpha()	"abc".isalpha() ‚Üí True
18	isascii()	ASCII characters only	str.isascii()	"abc".isascii() ‚Üí True
19	isdecimal()	Decimal numbers	str.isdecimal()	"123".isdecimal() ‚Üí True
20	isdigit()	Digits only	str.isdigit()	"123".isdigit() ‚Üí True
21	isidentifier()	Valid variable name	str.isidentifier()	"var1".isidentifier() ‚Üí True
22	islower()	All lowercase	str.islower()	"abc".islower() ‚Üí True
23	isnumeric()	Numeric value	str.isnumeric()	"123".isnumeric() ‚Üí True
24	isprintable()	Printable chars	str.isprintable()	"abc".isprintable() ‚Üí True
25	isspace()	Only spaces	str.isspace()	" ".isspace() ‚Üí True
26	istitle()	Title case	str.istitle()	"Hello World".istitle() ‚Üí True
27	isupper()	All uppercase	str.isupper()	"ABC".isupper() ‚Üí True
28	replace()	Replace text	str.replace(old,new)	"hello".replace("l","x") ‚Üí "hexxo"
29	translate()	Replace using table	str.translate(table)	Advanced use
30	removeprefix()	Remove prefix	str.removeprefix(prefix)	"unhappy".removeprefix("un") ‚Üí "happy"
31	removesuffix()	Remove suffix	str.removesuffix(suffix)	"hello.py".removesuffix(".py") ‚Üí "hello"
32	split()	Split string	str.split(sep)	"a,b,c".split(",") ‚Üí ['a','b','c']
33	rsplit()	Split from right	str.rsplit(sep)	"a,b,c".rsplit(",",1)
34	splitlines()	Split by lines	str.splitlines()	"a\nb".splitlines()
35	join()	Join list to string	"sep".join(list)	",".join(['a','b']) ‚Üí "a,b"
36	partition()	Split into 3 parts	str.partition(sep)	"abc".partition("b")
37	rpartition()	Split from right	str.rpartition(sep)	"abc".rpartition("b")
38	strip()	Remove spaces both sides	str.strip()	" hi ".strip() ‚Üí "hi"
39	lstrip()	Remove left spaces	str.lstrip()	" hi".lstrip()
40	rstrip()	Remove right spaces	str.rstrip()	"hi ".rstrip()
41	format()	Format string	"{}".format(val)	"Hello {}".format("Ram")
42	format_map()	Format using dict	str.format_map(dict)	
43	encode()	Convert to bytes	str.encode()	"abc".encode()
String Slicing in Python
String slicing means extracting a part (substring) of a string using index positions.
________________________________________
üîπ Basic Syntax
string[start : end : step]
Part	Meaning
start	Starting index (included)
end	Ending index (excluded)
step	Jump value (optional)
Example String
s = "Hello World"
Index Position:
 H  e  l  l  o     W  o  r  l  d
 0  1  2  3  4  5  6  7  8  9 10
Negative Index:
-11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1
 



3. Set Data Type
set
In Python Data Types, Set is an unordered collection of data types that is iterable, mutable, and has no duplicate elements. The order of elements in a set is undefined though it may consist of various elements.
Create a Set in Python
Sets can be created by using the built-in set() function with an iterable object or a sequence by placing the sequence inside curly braces, separated by a ‚Äòcomma‚Äô. The type of elements in a set need not be the same, various mixed-up data type values can also be passed to the set.
 Example:
# initializing empty set
s1 = set()

s1 = set("GeeksForGeeks")
print("Set with the use of String: ", s1)

s2 = set(["Geeks", "For", "Geeks"])
print("Set with the use of List: ", s2)

Access Set Items
Set items cannot be accessed by referring to an index, since sets are unordered the items have no index. But we can loop through the set items using a for loop, or ask if a specified value is present in a set, by using the keyword in.
set1 = set(["Geeks", "For", "Geeks"]) #Duplicates are removed automatically
print(set1) 

# loop through set
for i in set1:
   print(i, end=" ") #prints elements one by one
  
# check if item exist in set   
print("Geeks" in set1)




 
 
________________________________________


4.  Dictionary Data Type
A dictionary in Python is a collection of data values, used to store data values like a map, unlike other Python Data Types, a Dictionary holds a key: value pair. Key-value is provided in dictionary to make it more optimized. Each key-value pair in a Dictionary is separated by a colon : , whereas each key is separated by a ‚Äòcomma‚Äô.
Create a Dictionary in Python
Values in a dictionary can be of any datatype and can be duplicated, whereas keys can‚Äôt be repeated and must be immutable. The dictionary can also be created by the built-in function dict().
Note - Dictionary keys are case sensitive, the same name but different cases of Key will be treated distinctly. 
 
Example:
# initialize empty dictionary
d = {}
d = {1: 'Geeks', 2: 'For', 3: 'Geeks'}
print(d)
# creating dictionary using dict() constructor
d1 = dict({1: 'Geeks', 2: 'For', 3: 'Geeks'})
print(d1)
Accessing Key-value in Dictionary
In order to access items of a dictionary refer to its key name. Key can be used inside square brackets. Using get() method we can access dictionary elements.
d = {1: 'Geeks', 'name': 'For', 3: 'Geeks'}

# Accessing an element using key
print(d['name'])

# Accessing a element using get
print(d.get(3)) ________________________________________
5.Boolean Data Type
Python Boolean Data type is one of the two built-in values, True or False. Boolean objects that are equal to True are truthy (true) and those equal to False are falsy (false). However non-Boolean objects can be evaluated in a Boolean context as well and determined to be true or false. It is denoted by class bool.
Example:
x = 10
print(x > 5)   # True
print(x < 5)   # False

print(type(True))
print(type(False))
print(type(true))
________________________________________
6. NoneType
None
Definition:
None represents absence of value or no value assigned.
Example:
result = None
print(result)

 1. What is a Variable?
Definition:
A variable is a name used to store a value in the computer‚Äôs memory.
The value of a variable can change during program execution.
In simple words:
Variable = a container to store data
________________________________________
How to Create a Variable in Python?
In Python, you do not need to declare the data type of a variable.
Example:
x = 10
name = "Python"
pi = 3.14
________________________________________
Parts of a Variable Assignment
a = 5
‚Ä¢	a ‚Üí variable name
‚Ä¢	= ‚Üí assignment operator
‚Ä¢	5 ‚Üí value
Python automatically detects the data type.
________________________________________
 Examples of Variables with Different Data Types
a = 10          # int
b = 2.5         # float
c = 3 + 4j      # complex
d = "Hello"     # string
e = True        # boolean
________________________________________
 Dynamic Typing in Python
Python is a dynamically typed language.
Example:
x = 10
print(type(x))

x = "Hello"
print(type(x))
The same variable can store different types of values at different times.
________________________________________
üîπ 6. Multiple Variable Assignment
(a) Same value to multiple variables
a = b = c = 10
(b) Different values to different variables
x, y, z = 1, 2, 3
________________________________________
üîπ 7. Variable Naming Rules
‚úî Can contain letters, digits, and underscore
‚úî Must start with a letter or underscore
‚ùå Cannot start with a digit
‚ùå Cannot use Python keywords
Valid names:
name
_value
total1
Invalid names:
1name
class
my-name
________________________________________
üîπ 8. Case Sensitivity
Python is case-sensitive.
age = 20
Age = 25
age and Age are different variables.
________________________________________
üîπ 9. Variable Scope (Basic Idea)
‚Ä¢	Local Variable ‚Üí declared inside a function
‚Ä¢	Global Variable ‚Üí declared outside a function
Example:
x = 10   # global variable

def show():
    y = 5   # local variable
    print(y)

show()
print(x)



üîπ 1. What is an Operator?
Definition:
An operator is a symbol that is used to perform operations on variables and values.
üëâ In simple words:
Operator = performs some action on data
 Example of Operator
a = 10
b = 5
c = a + b
print(c)
Here, + is an operator that adds two values.
 Types of Operators in Python
________________________________________
1. Arithmetic Operators
Used to perform mathematical calculations.
Operator	  Name	Example
+	Addition	10 + 5
-	Subtraction	10 - 5
*	Multiplication	10 * 5
/	Division	10 / 5
%	Modulus	10 % 3
**	Exponent	2 ** 3
//	Floor Division	10 // 3
2. Relational (Comparison) Operators
Used to compare two values.
Result is always True or False.
Operator	Meaning
==	Equal to
!=	Not equal to
>	Greater than
<	Less than
>=	Greater than or equal to
<=	Less than or equal to


3. Logical Operators
Used to combine conditional statements.
Operator	Meaning
and	True if both conditions are true
or	True if at least one condition is true
not	Reverses the result
4. Assignment Operators
Used to assign values to variables.
Operator	Example	Meaning
=	a = 10	Assign
+=	a += 5	a = a + 5
-=	a -= 2	a = a - 2
*=	a *= 3	a = a * 3
/=	a /= 2	a = a / 2
5. Bitwise Operators
Used to perform operations on binary numbers.
Operator	Name
&	AND
`	`
^	XOR
~	NOT
<<	Left Shift
>>	Right Shift
6. Membership Operators
Used to check whether a value is present in a sequence.
Operator	Meaning
in	Present
not in	Not present
7. Identity Operators
Used to compare memory location (not value).
Operator	Meaning
is	Same object
is not	Different object

1. What is a Control Statement?
Definition:
Control statements are used to control the flow of execution of a program based on conditions or loops.

Control statements decide which code will run and how many times.
 Types of Control Statements in Python
Python control statements are mainly divided into 3 types:

 

Decision (Conditional) Statements
Used to make decisions based on conditions.
 (a) if Statement
Executes code only if condition is True.
age = 18

if age >= 18:
    print("Eligible to vote")
(b) if-else Statement
Executes one block if condition is True,
otherwise executes else block.
num = 7

if num % 2 == 0:
    print("Even number")
else:
    print("Odd number")
(c) if-elif-else Statement
Used to check multiple conditions.
marks = 75

if marks >= 90:
    print("Grade A")
elif marks >= 60:
    print("Grade B")
else:
    print("Grade C")
 (d) Nested if
if statement inside another if.
x = 10

if x > 0:
    if x % 2 == 0:
        print("Positive Even")
(e)Match statement
The match statement checks a value against multiple patterns and executes the corresponding block, similar to switch-case.

Basic Syntax
match variable:
    case value1:
        # code block for value1
    case value2:
        # code block for value2
    case _:   # default / else
        # code block if nothing matches



Example

day = input("Enter day: ")

match day:
    case "Monday":
        print("Start of work week")
    case "Friday":
        print("Last work day")
    case "Sunday":
        print("Weekend")
    case _:   # default
        print("Midweek day")
________________________________________
Looping Statements
Used to repeat a block of code.
(a) for Loop
Used when number of iterations is known.
for i in range(1, 6):
    print(i)
 (b) while Loop
Used when number of iterations is not known.
i = 1
while i <= 5:
    print(i)
    i += 1
________________________________________

Jump (Control Transfer) Statements
Used to change loop execution.
üîπ (a) break
Terminates the loop immediately.
for i in range(1, 10):
    if i == 5:
        break
    print(i)
üîπ (b) continue
Skips current iteration and moves to next.
for i in range(1, 6):
    if i == 3:
        continue
    print(i)
üîπ (c) pass
Does nothing (used as placeholder).
for i in range(5):
    pass


1. What is a Function?
Definition:
A function is a block of code that performs a specific task and can be reused multiple times.
üëâ Simple words:
Function = reusable code block
________________________________________
  Why use Functions?
‚Ä¢	Avoid code repetition
‚Ä¢	Organize code
‚Ä¢	Easier to debug and maintain
‚Ä¢	Reusable anywhere in the program
. Syntax
def function_name(parameters):
    # code block
    return value   # optional


‚Ä¢	def ‚Üí keyword to define function
‚Ä¢	function_name ‚Üí any valid name
‚Ä¢	parameters ‚Üí input values (optional)
‚Ä¢	return ‚Üí output value (optional)
Types of Functions in Python
Python functions can be classified in different ways:
________________________________________
A) Built-in Functions
‚Ä¢	Functions already defined by Python.
‚Ä¢	Examples: print(), len(), sum(), max(), min(), input()
arr = [10, 20, 30]
print(len(arr))  # Output: 3
print(max(arr))  # Output: 30
________________________________________
B) User-defined Functions
‚Ä¢	Functions created by the programmer to perform specific tasks.
                    def greet(name):
                     print("Hello", name)
                 greet("Alice")  # Output: Hello Alice
Example 1: Simple Function	
def greet():
    print("Hello, welcome to Python!")
greet()   # calling the function

What is a Parameterized Function?
Definition:
A parameterized function is a function that takes one or more inputs (parameters) to perform a task.
üëâ Simple words:
‚ÄúFunction with inputs‚Äù
________________________________________
üîπ 2. Syntax
def function_name(parameter1, parameter2, ...):
    # code using parameters
‚Ä¢	parameter1, parameter2 ‚Üí input values for the function
‚Ä¢	Parameters make the function flexible and reusable
________________________________________
‚úÖ 3. Example 1: Add two numbers
def add(a, b):   # a and b are parameters
    sum = a + b
    print("Sum:", sum)

add(10, 20)      # calling function with arguments
add(5, 15)

What is a Return Value?
Definition:
A return value is the output a function gives back to the part of the program that called it.
üëâ Simple words:
‚ÄúReturn = function ka result jo main program me use hota hai‚Äù
________________________________________
 Syntax
def function_name(parameters):
    # code block
    return value
‚Ä¢	return keyword ‚Üí value ko function se bahar bhejne ke liye use hota hai
‚Ä¢	Function execution ke baad value caller ko wapas milti hai
________________________________________
 Example : Add two numbers
def add(a, b):
    return a + b   # return sum

result = add(10, 20)   # calling function
print("Sum:", result)

What is Recursion?
A recursive function is a function that calls itself to solve smaller instances of the same problem.
Instead of using loops, recursion divides a problem into smaller subproblems until it reaches a base case (the condition that stops the recursion).
Structure of a recursive function:
def function_name(parameters):
    if base_case_condition:
        return some_value  # Stops the recursion
    else:
        return function_name(smaller_problem)  # Calls itself

Example 1: Factorial using Recursion
Factorial of n (denoted n!) is:
n!=n√ó(n‚àí1)√ó(n‚àí2)‚Ä¶1n! = n \times (n-1) \times (n-2) \dots 1n!=n√ó(n‚àí1)√ó(n‚àí2)‚Ä¶1 
Recursive definition:
‚Ä¢	Base case: 0! = 1
‚Ä¢	Recursive step: n! = n * (n-1)!
Python code:
def factorial(n):
    if n == 0:  # Base case
        return 1
    else:
        return n * factorial(n - 1)  # Recursive call

print(factorial(5))  # Output: 120


What is an Array?
‚Ä¢	An array is a data structure that stores elements of the same type in continuous memory locations.
‚Ä¢	Example: [2, 4, 6, 8, 10]
Key points:
‚Ä¢	Fixed size (in languages like C/C++)
‚Ä¢	Indexed ‚Üí first element has index 0
‚Ä¢	Efficient for accessing elements
________________________________________
Types of Arrays
1.	One-dimensional array (1D array)
o	A single row of elements
o	Example: [1, 2, 3, 4, 5]
2.	Two-dimensional array (2D array / Matrix)
o	Elements arranged in rows and columns
o	Example:
o	[[1, 2, 3],
o	 [4, 5, 6],
o	 [7, 8, 9]]
3.	Multi-dimensional array (3D or more)
o	Array of arrays of arrays
o	Example: 3D ‚Üí arr[x][y][z]
What is a 1D Array?
‚Ä¢	A 1D array is a linear collection of elements stored in a continuous memory location.
‚Ä¢	All elements are of the same data type.
‚Ä¢	Each element can be accessed using its index (starting from 0).
Example:
arr = [10, 20, 30, 40, 50]
‚Ä¢	arr[0] = 10
‚Ä¢	arr[3] = 40
________________________________________
Basic Operations on 1D Array
Access or print all elements of the array.
arr = [10, 20, 30, 40, 50]
for i in range(len(arr)):
    print(arr[i])

What is a 2D Array?
‚Ä¢	A 2D array is an array of arrays.
‚Ä¢	Think of it as a matrix with rows and columns.
‚Ä¢	Each element can be accessed using two indices: arr[row][column].
Example:
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
‚Ä¢	matrix[0][0] = 1
‚Ä¢	matrix[1][2] = 6
________________________________________
 

Basic Operations on 2D Array
Print all elements of the matrix.
rows = len(matrix)
cols = len(matrix[0])

for i in range(rows):
    for j in range(cols):
        print(matrix[i][j], end=" ")
    print()
What is a 3D Array?
‚Ä¢	A 3D array is an array of 2D arrays.
‚Ä¢	Think of it as layers of matrices stacked together.
‚Ä¢	Each element is accessed using three indices: arr[layer][row][column].
Example:
arr = [
    [   # Layer 0
        [1, 2, 3],
        [4, 5, 6]
    ],
    [   # Layer 1
        [7, 8, 9],
        [10, 11, 12]
    ]
]
‚Ä¢	arr[0][0][1] = 2 ‚Üí layer 0, row 0, column 1
‚Ä¢	arr[1][1][2] = 12 ‚Üí layer 1, row 1, column 2
________________________________________
 Traversal of 3D Array
‚Ä¢	Use three nested loops: layer ‚Üí row ‚Üí column
for layer in range(len(arr)):
    print(f"Layer {layer}:")
    for row in range(len(arr[layer])):
        for col in range(len(arr[layer][row])):
            print(arr[layer][row][col], end=" ")
        print()
    print()
 

Exception Handling in Python
 Definition
Exception Handling is a mechanism in Python to handle runtime errors so that the program does not crash and can continue execution.
‚Ä¢	An exception is an error that occurs during program execution.
‚Ä¢	Python provides a way to catch these exceptions using try, except, else, and finally blocks.
________________________________________
 Types of Exceptions
Exceptions in Python can be broadly divided into:

A) Built-in Exceptions
These are predefined exceptions in Python. Some common ones are:
Exception	Description	Example
ZeroDivisionError	Division by zero	10/0
ValueError	Invalid value type	int("abc")
TypeError	Wrong data type	"1"+1
IndexError	Accessing invalid index in list/array	arr[5] when arr has 3 elements
KeyError	Accessing invalid key in dictionary	dict["name"]
FileNotFoundError	File does not exist	open("abc.txt")
AttributeError	Accessing invalid attribute	"abc".uppercase()
________________________________________
B) User-defined Exceptions
‚Ä¢	You can create your own exceptions using raise and class
‚Ä¢	Useful for custom error handling
Example:
class MyError(Exception):
    pass

num = -5
if num < 0:
    raise MyError("Negative number not allowed")
________________________________________
 Syntax of Exception Handling
A) try-except
try:
    # code that may cause exception
    x = int(input("Enter number: "))
except ValueError:
    print("Invalid input!")
B) try-except-else
‚Ä¢	else executes only if no exception occurs
try:
    x = int(input("Enter number: "))
except ValueError:
    print("Invalid input!")
else:
    print("You entered:", x)
C) try-except-finally
‚Ä¢	finally executes always, even if an exception occurs
try:
    x = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
finally:
    print("This always executes")
D) Raising Exceptions
x = -1
if x < 0:
    raise ValueError("Number cannot be negative")
________________________________________
 Full Example with Multiple Exceptions
try:
    num1 = int(input("Enter first number: "))
    num2 = int(input("Enter second number: "))
    result = num1 / num2
except ValueError:
    print("Error: Please enter valid numbers")
except ZeroDivisionError:
    print("Error: Cannot divide by zero")
else:
    print("Division Result:", result)
finally:
    print("Program execution completed")
Sample Output 1 (Valid Input):
Enter first number: 10
Enter second number: 2
Division Result: 5.0
Program execution completed
Sample Output 2 (Division by zero):
Enter first number: 10
Enter second number: 0
Error: Cannot divide by zero
Program execution completed

File Handling in Python
 Definition
File Handling is a way to read data from a file and write data to a file using Python.
‚Ä¢	Files are used to store data permanently on disk.
‚Ä¢	Python provides built-in functions to create, open, read, write, and close files.
________________________________________
 Types of Files
1.	Text Files (.txt)
o	Contains plain text
o	Readable by humans
o	Example: "data.txt"
2.	Binary Files (.bin, .jpg, .png)
o	Contains binary data
o	Not human-readable
o	Example: Images, videos, or Excel files
________________________________________



File Modes
Mode	 Description
'r'	Read (default) ‚Äì Opens file for reading
'w'	Write ‚Äì Opens file for writing (creates file if not exists, overwrites if exists)
'a'	Append ‚Äì Opens file to add data at the end
'x'	Create ‚Äì Creates file, fails if file already exists
'rb'	Read binary
'wb'	Write binary
'ab'	Append binary
'r+'	Read and write

Basic File Operations
A) Opening and Closing a File
file = open("example.txt", "w")  # Open file in write mode
file.write("Hello Python\n")
file.close()  # Always close the file
________________________________________
B) Using with Statement (Recommended)
‚Ä¢	Automatically closes the file
with open("example.txt", "w") as file:
    file.write("Hello Python\n")
    file.write("File handling is easy\n")
# File is automatically closed here
________________________________________
C) Reading a File
with open("example.txt", "r") as file:
    content = file.read()  # Read whole file
    print(content)
‚Ä¢	Read line by line
with open("example.txt", "r") as file:
    for line in file:
        print(line, end="")
‚Ä¢	Read specific number of characters
with open("example.txt", "r") as file:
    print(file.read(5))  # Reads first 5 characters
________________________________________
D) Writing to a File
‚Ä¢	Write mode (w) ‚Üí Overwrites file
‚Ä¢	Append mode (a) ‚Üí Adds at the end
with open("example.txt", "a") as file:
    file.write("This is appended text\n")
________________________________________
E) Renaming and Deleting Files
import os

# Rename file
os.rename("example.txt", "newfile.txt")

# Delete file
os.remove("newfile.txt")
________________________________________
F) Working with Binary Files
# Writing binary data
with open("image.jpg", "rb") as file:
    data = file.read()

# Reading binary data
with open("copy.jpg", "wb") as file:
    file.write(data)
________________________________________
G) Checking if File Exists
import os
if os.path.exists("example.txt"):
    print("File exists")
else:
    print("File does not exist")
________________________________________
‚úÖ Best Practices for File Handling
1.	Always use with for automatic closing
2.	Handle exceptions while reading/writing
3.	Always check file existence before deleting
4.	Use binary mode for non-text files
________________________________________
H) Example: Complete Program
try:
    with open("example.txt", "w") as file:
        file.write("Python File Handling\n")
        file.write("Learn with examples\n")
    
    with open("example.txt", "r") as file:
        print("File content:\n", file.read())

except FileNotFoundError:
    print("File not found")
except Exception as e:
    print("Error:", e)
finally:
    print("Program completed")
Output:
File content:
Python File Handling
Learn with examples
Program completed

Summary: Most Used File Functions in Python
1.	open()
2.	close()
3.	read(), readline(), readlines()
4.	write(), writelines()
5.	seek(), tell(), truncate()
6.	name, mode, closed, readable(), writable()
7.	with open() (context manager)
8.	os.rename(), os.remove(), os.path.exists()



OOP in Python (Object-Oriented Programming)
________________________________________
 Definition
Object-Oriented Programming (OOP) is a programming paradigm that organizes code using objects and classes.
‚Ä¢	Class ‚Üí Blueprint for objects
‚Ä¢	Object ‚Üí Instance of a class
‚Ä¢	OOP Concept ‚Üí Combines data (attributes) and functions (methods) together
Python supports OOP fully.
Advantages of OOP
1.	Modularity: Code is divided into classes and objects
2.	Reusability: Use existing classes with inheritance
3.	Maintainability: Easier to manage large programs
4.	Encapsulation: Protects data from unauthorized access
5.	Polymorphism: Same function name, different behaviors
6.	Abstraction: Hides internal details, shows only important info
Key Features of OOP (One-line Definition)
1.	Class & Object: Class is a blueprint; object is its instance.
2.	Encapsulation: Hiding internal data and controlling access.
3.	Inheritance: Reusing properties and methods from a parent class.
4.	Polymorphism: Same function behaves differently in different contexts.
5.	Abstraction: Hiding internal details and showing only essential features.
6.	Constructor: Special method __init__() that initializes an object.
7.	Data Hiding: Protecting internal data using private/protected attributes.
 
Class and Object in Python
________________________________________
Definition
‚Ä¢	Class: A blueprint or template for creating objects. It defines attributes (data) and methods (functions).
‚Ä¢	Object: An instance of a class that contains real data and can use the class methods.
Analogy:
Class = Car blueprint, Object = Actual car built from blueprint
________________________________________
Types of Classes / Objects
A) Types of Classes
1.	User-defined Class: Created by the programmer
2.	Built-in Class: Predefined in Python (e.g., list, dict, str)
B) Types of Objects
1.	Instance Object: Created from a class using constructor
2.	Class Object: The class itself can also be treated as an object in Python
Syntax
# Class Syntax
class ClassName:
    # class attributes
    # constructor
    def __init__(self, parameters):
        # initialize attributes
        self.attribute = parameter

    # methods
    def method_name(self):
        # code
        pass

# Object Syntax
object_name = ClassName(arguments)

Example
# Define a class
class Person:
    def __init__(self, name, age):  # Constructor
        self.name = name          # Attribute
        self.age = age

    def greet(self):               # Method
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")

# Create objects
p1 = Person("Ajay", 20)
p2 = Person("Ravi", 25)

# Access methods
p1.greet()  # Output: Hello, my name is Ajay and I am 20 years old.
p2.greet()  # Output: Hello, my name is Ravi and I am 25 years old.


Constructor in Python
 Definition
A constructor is a special method in a class that automatically runs when an object is created.
‚Ä¢	It is used to initialize object attributes.
‚Ä¢	In Python, the constructor method is always named:
__init__()
________________________________________
 Types of Constructor
1.	Default Constructor
o	No parameters other than self
o	Initializes objects with default values
2.	Parameterized Constructor
o	Accepts parameters to initialize object with custom values
________________________________________
 Syntax
class ClassName:
    def __init__(self, parameters):  # Constructor
        self.attribute1 = value1
        self.attribute2 = value2
‚Ä¢	self refers to the current object
‚Ä¢	Constructor runs automatically when the object is created
________________________________________
 Example
A) Default Constructor
class Person:
    def __init__(self):
        self.name = "Ajay"
        self.age = 21

p1 = Person()  # Constructor runs automatically
print(p1.name)  # Ajay
print(p1.age)   # 21
________________________________________
B) Parameterized Constructor
class Person:
    def __init__(self, name, age):  # Constructor with parameters
        self.name = name
        self.age = age

p1 = Person("Ajay", 21)  # Constructor initializes attributes
p2 = Person("Vijay", 22)

print(p1.name, p1.age)  # Ajay 21
print(p2.name, p2.age)  # Vijay 22
________________________________________
 Key Points
‚Ä¢	Constructor is optional, but recommended for initializing objects
‚Ä¢	Python allows only one __init__() per class (no overloading)
‚Ä¢	Multiple objects can have different values using parameterized constructor
Inheritance in Python
________________________________________
 Definition
Inheritance is an OOP concept where a class (child/subclass) inherits properties and methods from another class (parent/superclass).
‚Ä¢	Reuses existing code
‚Ä¢	Supports hierarchical relationships
Analogy:
Parent = Human ‚Üí Child = Boy/Girl (inherits characteristics like name, age, height)
Types of Inheritance
1.	Single Inheritance ‚Äì Child inherits from one parent
2.	Multiple Inheritance ‚Äì Child inherits from multiple parents
3.	Multilevel Inheritance ‚Äì Chain of inheritance (grandparent ‚Üí parent ‚Üí child)
4.	Hierarchical Inheritance ‚Äì Multiple children inherit from one parent
5.	Hybrid Inheritance ‚Äì Combination of more than one type
Advantages of Inheritance
1.	Code Reusability ‚Äì Reuse existing parent class methods/attributes
2.	Less Code Duplication ‚Äì Avoid rewriting same code in multiple classes
3.	Extensibility ‚Äì Easy to extend functionality in child class
4.	Method Overriding ‚Äì Child can override parent methods
5.	Organized & Maintainable ‚Äì Better structure in large programs
________________________________________
Disadvantages of Inheritance
1.	Tight Coupling ‚Äì Child depends on parent class
2.	Complexity ‚Äì Multiple inheritance can make code hard to read
3.	Increased Memory ‚Äì More objects and hierarchies
4.	Overridden mistakes ‚Äì If a child overrides parent method incorrectly, it can cause bugs
Syntax
# Single inheritance
class Parent:
    def parent_method(self):
        print("This is parent method")

class Child(Parent):   # Child inherits Parent
    def child_method(self):
        print("This is child method")

# Multiple inheritance
class Parent1:
    pass

class Parent2:
    pass

class Child(Parent1, Parent2):
    pass
Inheritance in Python ‚Äì All Types
________________________________________
1Single Inheritance
Definition:
‚Ä¢	A child class inherits from one parent class.
‚Ä¢	Simplest form of inheritance.
Syntax:
class Parent:
    # parent methods
    pass

class Child(Parent):
    # child methods
    pass
Example:
class Parent:
    def show(self):
        print("Parent method")

class Child(Parent):
    def display(self):
        print("Child method")

c = Child()
c.show()    # Parent method
c.display() # Child method
________________________________________
 Multiple Inheritance
Definition:
‚Ä¢	A child class inherits from more than one parent class.
‚Ä¢	Python allows multiple inheritance using comma-separated parent classes.
Syntax:
class Parent1:
    pass

class Parent2:
    pass

class Child(Parent1, Parent2):
    pass
Example:
class Parent1:
    def func1(self):
        print("Parent1 method")

class Parent2:
    def func2(self):
        print("Parent2 method")

class Child(Parent1, Parent2):
    def func3(self):
        print("Child method")

c = Child()
c.func1()  # Parent1 method
c.func2()  # Parent2 method
c.func3()  # Child method
________________________________________
 Multilevel Inheritance
Definition:
‚Ä¢	A chain of inheritance: Grandparent ‚Üí Parent ‚Üí Child.
‚Ä¢	Child inherits from parent, which inherits from grandparent.
Syntax:
class Grandparent:
    pass

class Parent(Grandparent):
    pass

class Child(Parent):
    pass
Example:
class Grandparent:
    def func1(self):
        print("Grandparent method")

class Parent(Grandparent):
    def func2(self):
        print("Parent method")

class Child(Parent):
    def func3(self):
        print("Child method")

c = Child()
c.func1()  # Grandparent method
c.func2()  # Parent method
c.func3()  # Child method
________________________________________
 Hierarchical Inheritance
Definition:
‚Ä¢	One parent class, multiple child classes.
‚Ä¢	Each child inherits from the same parent.
Syntax:
class Parent:
    pass

class Child1(Parent):
    pass

class Child2(Parent):
    pass
Example:
class Parent:
    def func(self):
        print("Parent method")

class Child1(Parent):
    def func1(self):
        print("Child1 method")

class Child2(Parent):
    def func2(self):
        print("Child2 method")

c1 = Child1()
c2 = Child2()
c1.func()  # Parent method
c2.func()  # Parent method
________________________________________
 Hybrid Inheritance
Definition:
‚Ä¢	Combination of multiple inheritance and multilevel inheritance.
‚Ä¢	Can be complex, but Python fully supports it.
Syntax:
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
Example:
class A:
    def funcA(self):
        print("A method")

class B(A):
    def funcB(self):
        print("B method")

class C(A):
    def funcC(self):
        print("C method")

class D(B, C):  # Hybrid
    def funcD(self):
        print("D method")

d = D()
d.funcA()  # A method
d.funcB()  # B method
d.funcC()  # C method
d.funcD()  # D method
________________________________________

Encapsulation in Python
________________________________________
Definition
Encapsulation is an OOP concept that restricts direct access to some of an object‚Äôs attributes and hides the internal representation of the object.
‚Ä¢	It helps in data hiding
‚Ä¢	Allows controlled access via getter and setter methods
Analogy:
‚Ä¢	Like a capsule in medicine: medicine is inside, you can only access it in a controlled way.
________________________________________
 Types of Encapsulation in Python
1.	Public ‚Äì Accessible from anywhere
2.	Protected ‚Äì Can be accessed within class and its subclasses (single underscore _)
3.	Private ‚Äì Accessible only inside class (double underscore __)
________________________________________
 Advantages of Encapsulation
1.	Data Hiding ‚Äì Protects object‚Äôs internal state
2.	Controlled Access ‚Äì Access via getter and setter methods
3.	Maintainability ‚Äì Easier to maintain and modify code
4.	Security ‚Äì Prevents accidental changes to data
5.	Flexibility ‚Äì Can change internal implementation without affecting outside code
________________________________________
 Disadvantages of Encapsulation
1.	Extra Code ‚Äì Need getters and setters for access
2.	Complexity ‚Äì Adds more methods to class
3.	Overhead ‚Äì Slight performance overhead for method calls
________________________________________
 Syntax
class ClassName:
    def __init__(self):
        self.public = 10          # Public
        self._protected = 20      # Protected
        self.__private = 30       # Private

    # Getter for private
    def get_private(self):
        return self.__private

    # Setter for private
    def set_private(self, value):
        self.__private = value
________________________________________
 Example
class Person:
    def __init__(self, name, age):
        self.name = name         # Public
        self._age = age          # Protected
        self.__salary = 50000    # Private

    # Getter for private
    def get_salary(self):
        return self.__salary

    # Setter for private
    def set_salary(self, value):
        if value > 0:
            self.__salary = value
        else:
            print("Invalid salary")

# Object
p = Person("Ajay", 21)

# Access public
print(p.name)  # Ajay

# Access protected (possible but should be avoided outside class)
print(p._age)  # 21

# Access private (direct access not allowed)
# print(p.__salary)  # AttributeError

# Access via getter
print(p.get_salary())  # 50000

# Change private via setter
p.set_salary(60000)
print(p.get_salary())  # 60000
________________________________________
Key Points
1.	Public attributes ‚Äì object.attribute ‚Üí accessible anywhere
2.	Protected attributes ‚Äì _attribute ‚Üí accessible in class & subclass (convention)
3.	Private attributes ‚Äì __attribute ‚Üí accessible only via getter/setter
4.	Helps in data hiding, security, and controlled modification
	
Polymorphism in Python
üîπ What is Polymorphism?
Polymorphism means "many forms".
In Python, polymorphism allows the same method name to behave differently for different objects.
üëâ Same function name
üëâ Different behavior
________________________________________
‚úÖ Types of Polymorphism in Python
1.	Function Polymorphism
2.	Operator Overloading
3.	Method Overriding
4.	Method Overloading (Simulated in Python)
________________________________________
1Ô∏è‚É£ Function Polymorphism
Same function works with different data types.
‚úÖ Example
print(len("Hello"))     # String
print(len([1, 2, 3]))   # List
print(len((10, 20)))    # Tuple
‚úî Output:
5
3
2
üëâ len() works differently for different objects.
________________________________________
2Ô∏è‚É£ Operator Overloading
Same operator behaves differently for different data types.
‚úÖ Example
print(5 + 3)        # Addition
print("Hi " + "All") # String Concatenation
print([1,2] + [3,4]) # List Merge
‚úî Output:
8
Hi All
[1, 2, 3, 4]
üëâ + operator works differently.
________________________________________
3Ô∏è‚É£ Method Overriding (Runtime Polymorphism)
Child class provides its own implementation of parent method.
‚úÖ Example
class Animal:
    def sound(self):
        print("Animal makes sound")

class Dog(Animal):
    def sound(self):
        print("Dog barks")

obj = Dog()
obj.sound()
‚úî Output:
Dog barks
üëâ Child method overrides parent method.
________________________________________
4Ô∏è‚É£ Method Overloading (Compile-Time Polymorphism ‚Äì Simulated)
Python does not support true method overloading.
But we can achieve it using default arguments.
‚úÖ Example
class Math:
    def add(self, a, b=0, c=0):
        print(a + b + c)

obj = Math()
obj.add(5, 10)
obj.add(5, 10, 15)
‚úî Output:
15
30
________________________________________
üîπ Polymorphism with Different Classes
Different classes having same method name.
‚úÖ Example
class Dog:
    def sound(self):
        print("Dog barks")

class Cat:
    def sound(self):
        print("Cat meows")

for animal in (Dog(), Cat()):
    animal.sound()
‚úî Output:
Dog barks
Cat meows

